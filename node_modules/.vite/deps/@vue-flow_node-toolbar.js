import {
  Teleport,
  computed,
  createBlock,
  createCommentVNode,
  createElementBlock,
  defineComponent,
  inject,
  mergeProps,
  openBlock,
  renderSlot,
  unref
} from "./chunk-UWRLCAF5.js";
import "./chunk-XNHBATJA.js";

// ../../node_modules/.pnpm/@vue-flow+node-toolbar@1.1.0_@vue-flow+core@1.39.0_vue@3.3.4_/node_modules/@vue-flow/node-toolbar/dist/vue-flow-node-toolbar.mjs
import { Position as p, NodeIdInjection as O, useVueFlow as P, getRectOfNodes as S } from "@vue-flow/core";
var j = {
  name: "NodeToolbar",
  compatConfig: { MODE: 3 },
  inheritAttrs: false
};
var D = defineComponent({
  ...j,
  props: {
    nodeId: null,
    isVisible: { type: Boolean },
    position: { default: p.Top },
    offset: { default: 10 },
    align: { default: "center" }
  },
  setup(g) {
    const t = g, m = inject(O, null), { viewportRef: c, viewport: b, getSelectedNodes: v, findNode: f } = P();
    function x(e, o, r, i, h) {
      let l = 0.5;
      h === "start" ? l = 0 : h === "end" && (l = 1);
      let n = [
        (e.x + e.width * l) * o.zoom + o.x,
        e.y * o.zoom + o.y - i
      ], a = [-100 * l, -100];
      switch (r) {
        case p.Right:
          n = [
            (e.x + e.width) * o.zoom + o.x + i,
            (e.y + e.height * l) * o.zoom + o.y
          ], a = [0, -100 * l];
          break;
        case p.Bottom:
          n[1] = (e.y + e.height) * o.zoom + o.y + i, a[1] = 0;
          break;
        case p.Left:
          n = [
            e.x * o.zoom + o.x - i,
            (e.y + e.height * l) * o.zoom + o.y
          ], a = [-100, -100 * l];
          break;
      }
      return `translate(${n[0]}px, ${n[1]}px) translate(${a[0]}%, ${a[1]}%)`;
    }
    const s = computed(() => (Array.isArray(t.nodeId) ? t.nodeId : [t.nodeId || m || ""]).reduce((o, r) => {
      const i = f(r);
      return i && o.push(i), o;
    }, [])), I = computed(
      () => typeof t.isVisible == "boolean" ? t.isVisible : s.value.length === 1 && s.value[0].selected && v.value.length === 1
    ), z = computed(() => S(s.value)), w = computed(() => Math.max(...s.value.map((e) => (e.computedPosition.z || 1) + 1))), N = computed(() => ({
      position: "absolute",
      transform: x(z.value, b.value, t.position, t.offset, t.align),
      zIndex: w.value
    }));
    return (e, o) => (openBlock(), createBlock(Teleport, {
      to: unref(c),
      disabled: !unref(c)
    }, [
      unref(I) && unref(s).length ? (openBlock(), createElementBlock("div", mergeProps({ key: 0 }, e.$attrs, {
        style: unref(N),
        class: "vue-flow__node-toolbar"
      }), [
        renderSlot(e.$slots, "default")
      ], 16)) : createCommentVNode("", true)
    ], 8, ["to", "disabled"]));
  }
});
export {
  D as NodeToolbar
};
//# sourceMappingURL=@vue-flow_node-toolbar.js.map
